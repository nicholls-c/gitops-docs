{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the GitOps Learning Materials.</p>"},{"location":"#index","title":"Index","text":"<ul> <li> <p> Requirements</p> <p>Required software etc.</p> <p> Requirements</p> </li> <li> <p> Local Environment Setup</p> <p>Guidance on starting a local cluster with minikube.</p> <p> Minikube</p> </li> <li> <p> Installing ArgoCD</p> <p>Installation and configuration of ArgoCD.</p> <p> ArgoCD</p> </li> <li> <p> Cluster Bootstrapping</p> <p>Bootstrapping a local cluster using Argo App-of-Apps pattern.</p> <p> ArgoCD</p> </li> <li> <p> Deploying an App</p> <p>Deploying a simple Nginx web server using ArgoCD and GitOps.</p> <p> Let's Get That Deployed!</p> </li> <li> <p> Gateway API</p> <p>Install Gateway API and Istio CRDs for Ingress &amp;&amp; ServiceMesh.</p> <p> Gateway API</p> </li> </ul>"},{"location":"argo/app-of-apps/","title":"App of apps","text":""},{"location":"argo/app-of-apps/#app-of-apps","title":"App-of-Apps","text":"<p>You can now create an Argo \"App-of-Apps\". Essentialy, this is an Argo Application that bootstraps other argo applications.</p> <p>Update your repository details as required.</p> <pre><code>---\n# yaml-language-server: $schema=https://github.com/datreeio/CRDs-catalog/raw/refs/heads/main/argoproj.io/application_v1alpha1.json\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: app-of-apps\n  namespace: argocd\n  finalizers:\n    - resources-finalizer.argocd.argoproj.io\nspec:\n  project: default\n  sources:\n    - repoURL: git@github.com:nicholls-c/awesome-gitops.git\n      path: argo/apps\n      targetRevision: HEAD\n      directory:\n        recurse: true\n        include: \"*-application.yaml\"\n    - repoURL: git@github.com:nicholls-c/awesome-gitops.git\n      path: argo/projects\n      targetRevision: HEAD\n      directory:\n        recurse: true\n        include: \"*.yaml\"\n\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: argocd\n\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n    syncOptions:\n      - CreateNamespace=true\n</code></pre> <p>Noteworthy here is that we will use this app to managed any applications in source control matching this pattern: <code>*-application.yaml</code>. As long as you create an argo app with that naming pattern, this application will manage it.</p> <p>Also of note is that in this example, we create custom argo <code>projects</code> (containers to hold argo applications for better navigation and organisation).</p>"},{"location":"argo/gateway-api/","title":"Gateway API","text":"<p>To better reflect our AKS ingress moving forward, we can install <code>Istio</code> and the <code>Gateway API</code> CRds.</p> <p>Navigate to the <code>argo/ignore</code> folder, and move these folders into the argo apps directory: <pre><code>mv argo/ignore/mesh argo/apps\n</code></pre></p> <p>Ensure that any <code>repoURL</code> in any <code>*-application.yaml</code> files point correctly at your repository, not the template repository.</p> <p>Once you commit and push these folders, the Argo dashboard should extend considerably once you trigger the sync: </p> <p>We now have gateways from Gateway API, and a full Istio servicemesh in ambient mode. Additionally we have Kiali installed for distributing traces, and prometheus for metrics.</p> <p>Open you nginx manifest from earlier, and ensure the namespace is labelled for istio: <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\n  name: nginx\n  labels:\n    istio.io/dataplane-mode: ambient\n</code></pre></p> <p>Once this commit is finished, nginx is now a member of the mesh!</p> <p>If we run <code>minikube tunnel</code> from a terminal, we can now expose nginx using this new gateway.</p> <p>Extend our <code>nginx.yaml</code> to include the following: <pre><code># existing code above here\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: nginx-gateway\n  namespace: nginx\n  labels:\n    app: nginx\n    version: v1.25\nspec:\n  gatewayClassName: istio\n  listeners:\n  - name: http\n    port: 8080\n    protocol: HTTP\n    allowedRoutes:\n      namespaces:\n        from: Same\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: nginx-route\n  namespace: nginx\n  labels:\n    app: nginx\n    version: v1.25\nspec:\n  parentRefs:\n  - name: nginx-gateway\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  rules:\n  - backendRefs:\n    - name: nginx\n      kind: Service\n      group: \"\"\n      port: 80\n      weight: 1\n    matches:\n      - path:\n          type: PathPrefix\n          value: /\n</code></pre></p> <p>Once these changes have been sync'd and pushed: </p> <p>The tunnel will reflect the new gateway: </p> <p>And nginx will be browsable on 127.0.0.1:8080</p> <p>For good measure, navigate to <code>argo/argocd/manifests</code> and remove the <code>.bck</code> suffix from <code>gateway.yaml.bck</code>. This will expose a route to argo </p>"},{"location":"argo/getting-started/","title":"Getting Started","text":""},{"location":"argo/getting-started/#clone-template-directory","title":"Clone Template Directory","text":"<p>There is a starter repository that can be cloned that will help boostrap a new local cluster.</p> <ol> <li>Navigate to gitops-template repository</li> <li>Clone template repository: Use this template &gt; Create a new repository </li> <li>Add an Owner, Repository Name and change the visibility under Configuration to Private: </li> <li>Click Create repository</li> <li>GitHub should create the repository and take you to it.</li> <li>Grab git clone url: Code &gt; Local &gt; SSH &gt; Copy</li> <li>In bash, execute <code>git clone &lt;pasted_content&gt;</code></li> <li>Open in IDE of choice: <code>cd &lt;repo_name&gt; &amp;&amp; code .</code></li> </ol>"},{"location":"argo/getting-started/#bootstrap-local-cluster","title":"Bootstrap Local Cluster","text":"<p>There's a CLI bundled in the cloned repository for ensuring all our yaml manifests referencing github correctly.</p> <p>Execute: <pre><code>./utilities/bootstrap --github-username nicholls-c\n</code></pre></p> <p>Expected output: </p>"},{"location":"argo/getting-started/#app-of-apps","title":"App-of-Apps","text":"<p>We can now bootstrap our cluster with our Argo App-of-Apps.</p> <p>Apply our Argo bootstrap app to your minikube cluster: <pre><code>kubectl apply -f argo/app-of-apps.yaml\n</code></pre></p> <p>The ArgoUI should now show our app-of-apps: </p>"},{"location":"argo/installation/","title":"ArgoCD","text":"<ul> <li>ArgoCD</li> <li>Install</li> <li>Authenticate</li> </ul>"},{"location":"argo/installation/#authenticate","title":"Authenticate","text":""},{"location":"argo/installation/#create-and-set-a-namespace-for-argocd","title":"Create and set a namespace for ArgoCD:","text":"<pre><code>kubectl create namespace argocd; \nkubectl ns argocd;\n</code></pre>"},{"location":"argo/installation/#create-a-kubernetes-secret-from-your-github-ssh-key-dont-do-this-for-prod","title":"Create a kubernetes secret from your github <code>ssh</code> key (don't do this for prod ).","text":"<p>Update the path to your private github ssh key, and the name of your personal github. <pre><code>kubectl create secret generic github-ssh \\\n  --namespace argocd \\\n  --from-file=sshPrivateKey=/home/gr0ot/.ssh/id_ed25519 \\\n  --from-literal=type=git \\\n  --from-literal=url=git@github.com:nicholls-c\n</code></pre></p> <p>Label the secret for Argo: <pre><code>kubectl label secret github-ssh -n argocd argocd.argoproj.io/secret-type=repo-creds\n</code></pre></p>"},{"location":"argo/installation/#install","title":"Install","text":"<ol> <li>Install ArgoCD CRDs:    <pre><code>kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/v3.2.1/manifests/install.yaml\n</code></pre></li> <li>Verify installation: <code>kubectl -n argocd get statefulset</code></li> </ol>"},{"location":"argo/installation/#use","title":"Use","text":"<p>If you now forward the Argo service, you should get the UI rendering (you should also be able to click through <code>Settings</code> &gt; <code>Repository</code> and see your personal org). <pre><code>kubectl port-forward svc/argocd-server -n argocd 8082:443\n</code></pre></p> <p>To sign in to the UI, username is <code>admin</code>: </p> <p>The initial password can be retrieved using the following command: <pre><code>kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\"{.data.password}\" | base64 -d; echo\n</code></pre></p> <p>Which should lead you to the default UI. </p> <p>If you have installed the Argo CLI, you can also authenticate that: <pre><code>argocd login localhost:8082 --username admin --password \"$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\"{.data.password}\" | base64 -d; echo)\" --insecure\n</code></pre></p>"},{"location":"argo/next-steps/","title":"Deploying An App","text":"<p>Let's create a simple nginx app.</p> <p>First, we'll create a new argo application for our nginx deployment.</p> <ol> <li>Create a new folder for our deployment:</li> <li><code>mkdir -p argo/apps/nginx argo/apps/nginx/manifests</code></li> <li>Create the <code>argo/apps/nginx/nginx-application.yaml</code> from the following:    <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: nginx\n  namespace: argocd\n  finalizers:\n    - resources-finalizer.argocd.argoproj.io\nspec:\n  project: applications\n  source:\n    # make sure to update this ref!!\n    repoURL: git@github.com:nicholls-c/my-gitops.git\n    targetRevision: HEAD\n    # path to application manifests\n    path: argo/apps/nginx/manifests\n\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: nginx\n\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n    syncOptions:\n      - CreateNamespace=true\n      - ServerSideApply=true\n</code></pre></li> <li> <p>Create the following <code>nginx.yaml</code> in <code>argo/apps/nginx/manifests</code>:    <pre><code>---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: nginx\n  #labels:\n  #  istio.io/dataplane-mode: ambient\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx\n  namespace: nginx\n  labels:\n      app: nginx\n      version: v1.25\nspec:\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n        version: v1.25\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.25\n        ports:\n        - name: http\n          containerPort: 80\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: nginx\n  namespace: nginx\n  labels:\n    app: nginx\n    version: v1.25\nspec:\n  ports:\n  - name: http\n    port: 80\n    protocol: TCP\n    targetPort: 80\n  selector:\n    app: nginx\n  type: ClusterIP\n</code></pre></p> </li> <li> <p>Commit to git: <pre><code>git add .;\ngit commit -m 'feat: nginx argo app';\ngit push\n</code></pre></p> </li> <li> <p>And navigate back to our Argo App-of-Apps and click Sync &gt; Synchronize, we should see our <code>nginx</code> Argo app:    </p> </li> <li> <p>Navigate into our app, and it should reconcile and show as sync'd:    </p> </li> <li> <p>Now if we forward the nginx service: <code>kubectl -n nginx port-forward svc/nginx 8080:80</code></p> </li> <li> <p>We should get a <code>200</code> response from <code>curl</code>: </p> </li> <li> <p>And the default nginx site in our browser: </p> </li> </ol>"},{"location":"argo/next-steps/#kiali","title":"Kiali","text":"<p>To see distributed tracing in action: 1. Hit the nginx gateway a few times in curl. 2. Open kiali dashboard kiali 3. Ensure dashboard is set for:    - Namespace: nginx    - Traffic Animation: on    - Security: on</p> <p>And you should get a realtime map of traffic flowing through the mesh member: </p>"},{"location":"setup/minikube/","title":"Minikube","text":"<p>These guides have been tested using <code>Minikube</code>.</p> <p>Local k8s</p> <p>Other options are available. Namely <code>kind</code>. All steps should work on any local kubernetes offering.</p> <p>Start a local cluster: <pre><code># start minikube server\nminikube start \\\n--install-addons=true \\\n--driver=docker \\\n--kubernetes-version=v1.34.0\n</code></pre></p> <p>Enable addons: <pre><code># enable metallb\nminikube addons enable metallb\n\n# enable mettrics server\nminikube addons enable metrics-server\n</code></pre></p> <p>Whilst not required, it is recommended to setup an IP address range for <code>MetalLb</code> to expose as a <code>LoadBalancer</code> type in the more advanced scenarious: <pre><code># configure IP range for LoadBalancer type\nminikube addons configure metallb &lt;&lt; EOF\n192.168.49.100\n192.168.49.120\nEOF\n</code></pre></p> <p>We may as well start a tunnel, as any later use of Gateway CRDs will allow us to access services by their port over <code>127.0.0.1</code> on the host.</p> <p>Do this in a new terminal <pre><code>minikube tunnel\n</code></pre></p>"},{"location":"setup/setup/","title":"Local Setup","text":"<p>This guide assumes some local tooling.</p> <ul> <li><code>Windows Subsystem for Linux 2</code></li> <li>A <code>Debian</code> based distro (<code>Ubuntu-24.04</code> at time of writing)</li> <li><code>kubectl</code></li> <li><code>minikube</code></li> </ul>"}]}